# 莫队算法   学习笔记

我记得以前看过这个东西，当时居然没有看懂。现在回去补一下这个算法，发现还是挺简单的。

### 问题引入

给定一个长度为n的序列，进行q次询问，每次询问给定l,r，你需要将区间[l,r]中每种不同的数乘上出现次数平方，并把它们加起来输出

### 一种特殊的暴力算法

注意：这一部分内容相当重要，如果跳过，将会无法理解莫队算法

普通的暴力就不说了，每次询问枚举l到r暴力统计，这种暴力没有任何优化空间

我们来考虑这样一个情况：现在已经知道了区间[a,b]的答案，你要计算[l,r]的答案，可不可以利用已知区间[a,b]区计算出需要的东西呢？

当然可以。我们只要搞两个指针，一个指向询问左端点，一个指向右端点即可。当前我们的左指针指在a的位置，右指针指在b的位置，我们只需要把左指针一步一步移动到l，右指针一步一步移动到r，每移动一位计算答案的变化就可以了。指针移动一位，答案的变化是非常好计算的，只需减去这个数乘之前的出现次数平方，再加上这个数乘现在的出现次数平方就可以了。具体代码如下：

```cpp
while(pl<l) gao(pl,-1),pl++;
while(pl>l) pl--,gao(pl,1);
while(pr>r) gao(pr,-1),pr--;
while(pr<r) pr++,gao(pr,1);
```

其中gao函数的定义如下：

```cpp
void gao(int p,int k)
{
	ans-=sum[a[p]]*sum[a[p]]*a[p];
    a[p]+=k;
    ans+=sum[a[p]]*sum[a[p]]*a[p];
}
```

接下来我们分析这种算法的时间复杂度

从最坏情况考虑：假如询问依次是[1,1]、[n,n]、[1,1]、[n,n]…，那么每次询问，我们都要把左右指针各移动n次，所以时间复杂度是O(qn)，非常成功地和普通暴力一样了

那假如对询问排序？左端点为第一关键字，右端点为第二关键字？

假如询问依次是：[1,n/2]、[1,n]、[2,n/2]、[2,n]…，虽然每次询问左指针只需移动一次，但是右指针却需要移动n/2次，所以最后下来还是O(qn)的复杂度

排序这个思想是对的，只是排序方式不对

### 莫队算法

莫队算法的精髓就在于排序

下面先说做法，后面再来证复杂度

我们设m=sqrt(n)，然后对询问进行排序，第一关键字为l/m，第二关键字为r，排序后按上面的暴力算法做即可

咕咕咕？莫队算法就被你这一句话讲完了？这么简单？它的复杂度真的没问题吗？

当然没问题！下面来分析复杂度

我们考虑左指针的移动。由于是按块划分的，l/m相同的询问被分在了一起（下面称之为“同一块的询问”），这就使得同一块的询问中，左端点相差不会超过m，因此在同一块的询问中，左指针最多移动m步。跨块时，左指针最多移动2m步。一共进行q次操作，所以左指针的移动复杂度是O(qm)，也就是O(q\*sqrt(n))

接下来考虑右指针的移动。由于同一块的询问中，右端点是有序的，它们从左向右排列地非常整齐。因此对于一整个块而言，右指针顶多从最左端一步一步移到最右端，然后在这一块结束之后一步一步移动回来。我们一共有m个块，每个块最多使右指针移动2n次，所以右指针的移动复杂度是O(nm)，也就是O(n\*sqrt(n))

将上面分析的复杂度综合到一起，得出莫队的复杂度是O((n+q)sqrt(n))，跑正常的带一个log的数据结构题完全没问题。再加上常数碾压，将带两个log的数据结构按在地上摩擦也完全没问题

是不是非常优美？只是稍微改进了一下排序方式，复杂度就变得奇妙起来！

### 后话

莫队算法是有局限性的。它要求每一个位置对答案的贡献可加可减。如果不满足这个性质，就要考虑用别的算法，或者在莫队的基础上改进（如【BZOJ4358】permu）

总的来说，莫队是一种非常好的~~暴力~~算法，简单易学，用处也还算是比较大。至少，你可以花不到10分钟学会它，性价比不是相当高吗？想当初我们学平衡树，花的时间甚至超过两个小时吧。