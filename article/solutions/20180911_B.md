# 【AGC010D】Decrementing 題解

### 題意

兩個人玩遊戲，每次在長度為n的序列中選擇一個大於1的數減1，然後整個序列除以所有數的gcd，首先把所有數變成1的人獲勝

### 題解

這題的難點，是你要發現若干個偶數的gcd居然可能大於2！這個超級難的！

好吧言歸正傳。。。

**結論一：如果一開始有一個1，其它都是偶數，那麼若是奇數個偶數，先手必勝，否則後手必勝（顯然）**

**結論二：如果一開始有奇數個偶數，先手必勝。**

說明：如果先手能保證每人每次只能取一個，那麼他就贏了。要想保證每人每次只能取一個也很簡單，先手只需任選一個偶數減1，再算上初始局面必然包含的一個奇數（否則初始gcd不為1），這樣就至少有兩個奇數了。此時若序列長度大於2，那麼序列的gcd必然為1，並且再讓任意一個數減1，序列的gcd仍然為1，後手此時顯然非常雞肋。

特殊情況是序列長度為2，那先手減了1之後，可能兩數相等，那正好直接贏了；要是不相等，並且減1之後出現了倍數關係，那沒什麼影響，顯然一個是另一個的奇數倍，約去gcd後就是一個1加上一個奇數，此時顯然先手就贏了。

**結論三：如果一開始有大於一個奇數，以及偶數個偶數，後手必勝**

說明：因為有大於一個奇數，所以選任意一個數減一，gcd必然還為1，此時結論二中的情況就輪到了後手的手上，先手就只能咕咕咕了

**其他情況下（一開始有偶數個偶數以及一個奇數），讓那個奇數減1，然後序列整體除以gcd（對，是gcd，不是2，艸），再重複進行上述三種判斷。因為每次至少除2，所以遞迴層數是log級別的**

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=100010;
int a[N],n,cnt[2];

bool gao()
{
    for(int i=1;i<=n;i++)
        if(a[i]&1) a[i]--;
    cnt[0]=cnt[1]=0;
    int gcd=a[1];
    for(int i=2;i<=n;i++)
        gcd=__gcd(a[i],gcd);
    for(int i=1;i<=n;i++)
        cnt[(a[i]/=gcd)&1]++;
    if(cnt[0]&1) return 1;
    else if(cnt[1]>1) return 0;
    else
    {
        for(int i=1;i<=n;i++)
            if(a[i]==1) return cnt[0]&1?1:0;
        return gao()^1;
    }
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",a+i);
        cnt[a[i]&1]++;
    }
    if(cnt[0]&1) puts("First");
    else if(cnt[1]>1) puts("Second");
    else
    {
        for(int i=1;i<=n;i++)
            if(a[i]==1){puts(cnt[0]&1?"First":"Second");return 0;}
        puts(gao()^1?"First":"Second");
    }
    return 0;
}
```

